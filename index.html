<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>QuestCards</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0f19; color: #e8eefc; }
    .wrap { max-width: 1040px; margin: 0 auto; padding: 16px; }
    .card {
      background: #121a2b;
      border: 1px solid rgba(232,238,252,.12);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    h1 { font-size: 18px; margin: 0 0 10px; letter-spacing: .2px; }
    .sub { font-size: 12px; opacity: .8; margin-bottom: 10px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 0 0 auto; }
    .btn {
      background: #223257;
      color: #e8eefc;
      border: 1px solid rgba(232,238,252,.18);
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      transition: transform .05s ease;
      user-select: none;
    }
    .btn:active { transform: scale(.98); }
    .btn.secondary { background: #18223a; }
    .btn.danger { background: #5b2430; }
    .btn.good { background: #1f4a34; }
    .pill {
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(232,238,252,.08);
      border: 1px solid rgba(232,238,252,.10);
      font-size: 12px;
      color: #d7e0ff;
    }
    .hr { height: 1px; background: rgba(232,238,252,.10); margin: 12px 0; }

    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 960px) { .grid { grid-template-columns: 360px 1fr; } }

    .panel { background: #0f1628; border: 1px solid rgba(232,238,252,.12); border-radius: 16px; padding: 12px; }
    .label { font-size: 12px; opacity: .82; margin-bottom: 6px; }

    input[type="file"] { color: #e8eefc; }
    textarea {
      width: 100%;
      min-height: 90px;
      border-radius: 14px;
      padding: 10px;
      background: #0f1628;
      color: #e8eefc;
      border: 1px solid rgba(232,238,252,.14);
      resize: vertical;
    }
    select, input[type="text"] {
      background: #0f1628;
      color: #e8eefc;
      border: 1px solid rgba(232,238,252,.14);
      border-radius: 12px;
      padding: 10px 10px;
      outline: none;
    }

    .flashcard {
      border-radius: 18px;
      background:
        radial-gradient(1200px 500px at 20% 10%, rgba(124,92,255,.12), transparent 60%),
        radial-gradient(900px 500px at 90% 90%, rgba(0,210,255,.10), transparent 60%),
        #0f1628;
      border: 1px solid rgba(232,238,252,.14);
      padding: 16px;
      min-height: 340px;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      position: relative;
      overflow: hidden;
    }
    .topbar { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between; }
    .bars { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .barWrap { width: 180px; }
    .barLabel { font-size: 11px; opacity: .8; margin-bottom: 4px; }
    .bar {
      height: 10px;
      border-radius: 999px;
      background: rgba(232,238,252,.10);
      border: 1px solid rgba(232,238,252,.12);
      overflow: hidden;
    }
    .bar > div { height: 100%; width: 0%; background: rgba(0,210,255,.55); transition: width .15s ease; }
    .bar.streak > div { background: rgba(124,92,255,.55); }

    .faceLabel {
      font-size: 12px;
      opacity: .8;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(232,238,252,.12);
      padding: 6px 10px;
      border-radius: 999px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .content {
      display: grid;
      place-items: center;
      text-align: center;
      padding: 12px;
      user-select: none;
    }
    .bigText {
      max-width: 900px;
      line-height: 1.25;
      font-size: clamp(18px, 2.5vw, 34px);
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .img {
      max-width: min(900px, 92vw);
      max-height: 280px;
      border-radius: 14px;
      margin: 14px auto 0;
      display: none;
      border: 1px solid rgba(232,238,252,.14);
    }
    .hintBox {
      display: none;
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px dashed rgba(232,238,252,.18);
      background: rgba(232,238,252,.06);
      font-size: 14px;
      opacity: .92;
      max-width: 860px;
    }

    .answerArea { display: grid; gap: 10px; }
    .choices { display: grid; grid-template-columns: 1fr; gap: 8px; max-width: 740px; margin: 0 auto; }
    @media (min-width: 700px) { .choices { grid-template-columns: 1fr 1fr; } }
    .choiceBtn { text-align: left; }

    .footer {
      display: flex;
      gap: 10px;
      justify-content: space-between;
      flex-wrap: wrap;
      align-items: center;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      place-items: center;
      padding: 16px;
      z-index: 9999;
    }
    .modalInner {
      width: min(620px, 96vw);
      background: #121a2b;
      border: 1px solid rgba(232,238,252,.14);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
    }
    .modalTitle { font-size: 16px; margin: 0 0 8px; }
    .loot {
      font-size: 40px;
      margin: 8px 0 10px;
      text-align: center;
    }
    .tiny { font-size: 12px; opacity: .82; }
    .k { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .bossBadge {
      display: none;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,120,120,.22);
      background: rgba(255,120,120,.10);
      color: #ffd1d1;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>QuestCards üÉè‚ö°</h1>
      <div class="sub">Short quests, power-ups, boss battles. No accounts. Nothing leaves the browser.</div>

      <div class="grid">
        <!-- LEFT: Setup -->
        <div class="panel">
          <div class="label">Load decks (TSV or CSV)</div>
          <div class="row">
            <input id="file" type="file" accept=".tsv,text/tab-separated-values,.csv,text/csv" multiple />
            <button class="btn secondary" id="loadSample">Load sample</button>
            <button class="btn secondary" id="clearAll">Clear</button>
          </div>

          <div class="hr"></div>

          <div class="label">Optional: paste TSV/CSV</div>
          <textarea id="csvPaste" placeholder="front	back	answer	choices	hint	tag	difficulty	front_image	back_image&#10;2+2	4	4	3|4|5|6	Think pairs	math	1		"></textarea>
          <div class="row" style="margin-top:10px;">
            <button class="btn secondary" id="loadPaste">Load pasted</button>
          </div>

          <div class="hr"></div>

          <div class="label">Game settings</div>
          <div class="row">
            <span class="pill" id="deckStatus">No decks loaded</span>
            <span class="pill" id="statsStatus">0 correct ¬∑ 0 missed</span>
          </div>

          <div class="row" style="margin-top:10px;">
            <label class="pill" style="display:inline-flex; gap:8px; align-items:center;">
              <input id="wheel" type="checkbox" /> Wheel of Chaos (mix decks)
            </label>
            <label class="pill" style="display:inline-flex; gap:8px; align-items:center;">
              <input id="audio" type="checkbox" /> Audio read-out
            </label>
            <label class="pill" style="display:inline-flex; gap:8px; align-items:center;">
              <input id="movement" type="checkbox" /> Movement prompts
            </label>
          </div>

          <div class="row" style="margin-top:10px;">
            <span class="pill">Difficulty:</span>
            <select id="diff">
              <option value="all">All</option>
              <option value="1">Easy (1)</option>
              <option value="2">Normal (2)</option>
              <option value="3">Spicy (3)</option>
            </select>

            <span class="pill">Mode:</span>
            <select id="mode">
              <option value="self">Self-score (fast)</option>
              <option value="quiz">Quiz (type or choose)</option>
            </select>
          </div>

          <div class="hr"></div>

          <div class="label">Start a sprint</div>
          <div class="row">
            <button class="btn good" data-sprint="120">2 min</button>
            <button class="btn good" data-sprint="300">5 min</button>
            <button class="btn good" data-sprint="600">10 min</button>
            <button class="btn danger" id="stop">Stop</button>
          </div>

          <div class="hr"></div>

          <div class="tiny">
            Power-ups charge on correct answers. Boss battle triggers after a few misses.
            Loot drops every 10 correct. Saved locally only.
          </div>
        </div>

        <!-- RIGHT: Game -->
        <div class="flashcard">
          <div class="topbar">
            <div class="bars">
              <span class="faceLabel" id="faceLabel">Ready</span>
              <span class="bossBadge" id="bossBadge">BOSS BATTLE</span>
              <span class="pill" id="timer">00:00</span>
              <span class="pill" id="cardCounter">0 / 0</span>
              <span class="pill" id="deckName">‚Äî</span>
            </div>

            <div class="bars">
              <div class="barWrap">
                <div class="barLabel">Power meter</div>
                <div class="bar"><div id="powerBar"></div></div>
              </div>
              <div class="barWrap">
                <div class="barLabel">Streak</div>
                <div class="bar streak"><div id="streakBar"></div></div>
              </div>
            </div>
          </div>

          <div class="content" id="contentArea">
            <div>
              <div class="bigText" id="cardText">Load a deck and start a sprint.</div>
              <img class="img" id="cardImg" alt="" />
              <div class="hintBox" id="hintBox"></div>
            </div>
          </div>

          <div class="answerArea" id="answerArea" style="display:none;">
            <div class="row" style="justify-content:center;">
              <input id="typedAnswer" type="text" placeholder="Type answer‚Ä¶" style="width:min(520px,92vw);" />
              <button class="btn" id="submitAnswer">Submit</button>
            </div>
            <div class="choices" id="choices"></div>
          </div>

          <div class="footer">
            <div class="row">
              <button class="btn secondary" id="btnReveal">Reveal üëÅÔ∏è</button>
              <button class="btn secondary" id="btnHint">Hint (cost 1 power)</button>
              <button class="btn secondary" id="btnSkip">Skip (cost 1 power)</button>
              <button class="btn secondary" id="btnFreeze">Freeze 10s (cost 2 power)</button>
            </div>

            <div class="row" id="selfScoreRow">
              <button class="btn good" id="gotIt">Got it ‚úÖ</button>
              <button class="btn danger" id="missedIt">Missed ‚ùå</button>
            </div>

            <div class="tiny">
              Keys: <span class="k">Enter</span> submit ¬∑ <span class="k">H</span> hint ¬∑ <span class="k">S</span> skip ¬∑ <span class="k">R</span> reveal
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal" id="modal">
    <div class="modalInner">
      <h2 class="modalTitle" id="modalTitle">Loot drop</h2>
      <div class="loot" id="lootIcon">‚ú®</div>
      <div id="modalBody" class="tiny"></div>
      <div class="row" style="margin-top:12px; justify-content:flex-end;">
        <button class="btn" id="closeModal">Close</button>
      </div>
    </div>
  </div>

<script>
  // -----------------------------
  // Utility helpers
  // -----------------------------
  function safeInt(v, fallback) {
    const n = parseInt(String(v || "").trim(), 10);
    return Number.isFinite(n) ? n : fallback;
  }

  function normalizeHeader(s) {
    return String(s || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, "_")
      .replace(/[^a-z0-9_]/g, "");
  }

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  // -----------------------------
  // Delimiter detection + parsing
  // -----------------------------
  function detectDelimiter(text) {
    const firstLine = text
      .replace(/\r\n/g, "\n")
      .replace(/\r/g, "\n")
      .split("\n")
      .find(l => l.trim().length > 0) || "";

    const commas = (firstLine.match(/,/g) || []).length;
    const tabs = (firstLine.match(/\t/g) || []).length;

    if (tabs > 0 && tabs >= commas) return "\t";
    return ",";
  }

  // Delimiter-aware parser supporting quotes/newlines
  function parseDelimited(text, delimiter) {
    const rows = [];
    let row = [];
    let cell = "";
    let inQuotes = false;

    text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i + 1];

      if (inQuotes) {
        if (ch === '"' && next === '"') { cell += '"'; i++; }
        else if (ch === '"') { inQuotes = false; }
        else { cell += ch; }
        continue;
      }

      if (ch === '"') {
        inQuotes = true;
      } else if (ch === delimiter) {
        row.push(cell.trim());
        cell = "";
      } else if (ch === "\n") {
        row.push(cell.trim());
        cell = "";
        if (row.some(v => v.length > 0)) rows.push(row);
        row = [];
      } else {
        cell += ch;
      }
    }

    row.push(cell.trim());
    if (row.some(v => v.length > 0)) rows.push(row);

    return rows;
  }

  // -----------------------------
  // State + DOM
  // -----------------------------
  const el = {
    file: document.getElementById("file"),
    loadSample: document.getElementById("loadSample"),
    clearAll: document.getElementById("clearAll"),
    csvPaste: document.getElementById("csvPaste"),
    loadPaste: document.getElementById("loadPaste"),

    deckStatus: document.getElementById("deckStatus"),
    statsStatus: document.getElementById("statsStatus"),

    wheel: document.getElementById("wheel"),
    audio: document.getElementById("audio"),
    movement: document.getElementById("movement"),
    diff: document.getElementById("diff"),
    mode: document.getElementById("mode"),

    timer: document.getElementById("timer"),
    cardCounter: document.getElementById("cardCounter"),
    deckName: document.getElementById("deckName"),
    faceLabel: document.getElementById("faceLabel"),
    bossBadge: document.getElementById("bossBadge"),

    cardText: document.getElementById("cardText"),
    cardImg: document.getElementById("cardImg"),
    hintBox: document.getElementById("hintBox"),

    answerArea: document.getElementById("answerArea"),
    typedAnswer: document.getElementById("typedAnswer"),
    submitAnswer: document.getElementById("submitAnswer"),
    choices: document.getElementById("choices"),
    selfScoreRow: document.getElementById("selfScoreRow"),

    powerBar: document.getElementById("powerBar"),
    streakBar: document.getElementById("streakBar"),

    btnReveal: document.getElementById("btnReveal"),
    btnHint: document.getElementById("btnHint"),
    btnSkip: document.getElementById("btnSkip"),
    btnFreeze: document.getElementById("btnFreeze"),

    gotIt: document.getElementById("gotIt"),
    missedIt: document.getElementById("missedIt"),
    stop: document.getElementById("stop"),

    modal: document.getElementById("modal"),
    modalTitle: document.getElementById("modalTitle"),
    lootIcon: document.getElementById("lootIcon"),
    modalBody: document.getElementById("modalBody"),
    closeModal: document.getElementById("closeModal"),
  };

  // decks = [{ name, cards: [{front,back,answer,choices[],hint,tag,difficulty,imgFront,imgBack}] }]
  let decks = [];
  let running = false;
  let remaining = 0;
  let tickHandle = null;

  let current = null; // { deckIndex, cardIndex, card }
  let filteredIndexByDeck = [];

  // Session stats
  let correct = 0;
  let missed = 0;
  let streak = 0;
  let power = 0; // max 5

  // Boss system
  let missQueue = [];
  let inBoss = false;
  let bossHP = 0;

  // Freeze timer
  let freezeUntil = 0;

  // Reveal state
  let showingBack = false;

  // Local storage
  const LS_KEY = "questcards_loot_v1";
  const LS_BEST = "questcards_best_v1";

  const LOOT = ["‚ú®", "üßø", "ü¶ä", "üêâ", "ü¶Ñ", "ü™ê", "üß†", "‚ö°", "üß©", "üóùÔ∏è", "üåô", "ü¶á", "üïØÔ∏è", "üéß", "üìö"];

  // 25 movement prompts
  const MOVES = [
    "Stand up and stretch your arms like you are charging solar panels ‚òÄÔ∏è",
    "Do 5 wall pushes. Yes, like a hero in training ü¶∏",
    "Spin once like a confused satellite ü™ê",
    "Touch a doorway, come back, and breathe once slow üå¨Ô∏è",
    "Shake out your hands and shoulders like a cat resetting its soul üêà",
    "Do 10 marching steps in place like you are leading an expedition ü•æ",
    "Roll your shoulders 6 times like you are shrugging off a villain monologue üòà",
    "Stand tall and do 3 slow deep breaths like a lighthouse in a storm üåä",
    "Do 5 calf raises like you are powering up rocket boosters üöÄ",
    "Do a gentle forward fold for 10 seconds like you are downloading calm üßò",
    "Do 8 toe taps on each foot like you are entering a cheat code üéÆ",
    "Reach up, then touch your toes, repeat 4 times like a stretchy noodle üß¨",
    "Do 5 big arm circles like you are stirring a cosmic soup ü•£",
    "Take 12 steps and count them out loud like a scientist verifying data üî¨",
    "Do 5 slow neck tilts (each side) like you are scanning for clues üïµÔ∏è",
    "Stand on one foot for 10 seconds like a flamingo judge ü¶©",
    "Do 6 gentle twists side-to-side like you are wringing out stress üßΩ",
    "Shake your legs out for 8 seconds like you are rebooting your OS üíª",
    "Do 5 ‚Äúair punches‚Äù slowly like you are fighting procrastination ü•ä",
    "Pretend you are opening a giant door: pull back 6 times üö™",
    "Walk to get water (or fake it) like you are on a secret mission ü•§",
    "Do 10 seconds of jazz hands like you are summoning focus ‚ú®",
    "Do 6 slow knee lifts like you are stepping over laser beams üî•",
    "Stand, look at something far away for 5 seconds, then near for 5 seconds üëÄ",
    "Do 5 gentle squats like you are compressing a spring for launch üåÄ"
  ];

  // -----------------------------
  // UI helpers
  // -----------------------------
  function setTimerDisplay(sec) {
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    el.timer.textContent = String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
  }

  function updateBars() {
    el.powerBar.style.width = (power / 5) * 100 + "%";
    el.streakBar.style.width = clamp(streak, 0, 10) * 10 + "%";
  }

  function setStatus() {
    const totalCards = decks.reduce((sum, d) => sum + d.cards.length, 0);
    el.deckStatus.textContent = decks.length ? `${decks.length} deck(s), ${totalCards} cards` : "No decks loaded";
    el.statsStatus.textContent = `${correct} correct ¬∑ ${missed} missed ¬∑ streak ${streak} ¬∑ power ${power}`;
    updateBars();
  }

  function showModal(title, icon, bodyHtml) {
    el.modalTitle.textContent = title;
    el.lootIcon.textContent = icon;
    el.modalBody.innerHTML = bodyHtml;
    el.modal.style.display = "grid";
  }

  function closeModal() {
    el.modal.style.display = "none";
  }

  function speak(text) {
    if (!el.audio.checked) return;
    if (!("speechSynthesis" in window)) return;
    const utter = new SpeechSynthesisUtterance(text);
    utter.rate = 1.0;
    utter.pitch = 1.0;
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utter);
  }

  function setCardDisplay(card, deckName, label) {
    el.deckName.textContent = deckName || "‚Äî";
    el.faceLabel.textContent = label || "Quest";
    el.hintBox.style.display = "none";
    el.hintBox.textContent = "";

    const text = showingBack ? (card?.back || card?.answer || "‚Äî") : (card?.front || "‚Äî");
    el.cardText.textContent = text;

    // image logic
    const imgUrl = showingBack ? (card?.imgBack || "") : (card?.imgFront || "");
    if (imgUrl) {
      el.cardImg.src = imgUrl;
      el.cardImg.alt = "card image";
      el.cardImg.style.display = "block";
      el.cardImg.onerror = () => { el.cardImg.style.display = "none"; };
    } else {
      el.cardImg.style.display = "none";
      el.cardImg.src = "";
      el.cardImg.alt = "";
    }

    if (!showingBack && card?.front) speak(card.front);
    if (showingBack && (card?.back || card?.answer)) speak(card.back || card.answer);
  }

  function setAnswerUI(card) {
    const mode = el.mode.value;

    // Boss badge
    el.bossBadge.style.display = inBoss ? "inline-flex" : "none";

    if (mode === "self") {
      el.answerArea.style.display = "none";
      el.selfScoreRow.style.display = "flex";
      return;
    }

    // Quiz mode
    el.answerArea.style.display = "grid";
    el.selfScoreRow.style.display = "none";

    // Typed answer
    el.typedAnswer.value = "";
    el.typedAnswer.placeholder = "Type answer‚Ä¶";

    // Choices
    el.choices.innerHTML = "";
    const choices = card?.choices || [];
    if (choices.length >= 2) {
      for (const c of choices) {
        const b = document.createElement("button");
        b.className = "btn secondary choiceBtn";
        b.textContent = c;
        b.onclick = () => gradeAnswer(c);
        el.choices.appendChild(b);
      }
    }
  }

  function updateCounter() {
    const total = decks.reduce((sum, d) => sum + getFilteredIndicesForDeck(d).length, 0);
    el.cardCounter.textContent = total ? "Active" : "0 / 0";
  }

  // -----------------------------
  // Filtering / selection
  // -----------------------------
  function getFilteredIndicesForDeck(deck) {
    const want = el.diff.value;
    if (want === "all") return deck.cards.map((_, i) => i);
    const w = safeInt(want, 0);
    const out = [];
    for (let i = 0; i < deck.cards.length; i++) {
      const d = deck.cards[i].difficulty;
      if (!d || d === w) out.push(i);
    }
    return out;
  }

  function rebuildFilters() {
    filteredIndexByDeck = decks.map(d => getFilteredIndicesForDeck(d));
    updateCounter();
  }

  function pickNextCardRef() {
    // Boss mode pulls from missQueue first
    if (inBoss && missQueue.length) {
      return missQueue.shift();
    }

    if (!decks.length) return null;

    const deckChoices = [];
    for (let di = 0; di < decks.length; di++) {
      const idxs = filteredIndexByDeck[di] || [];
      if (idxs.length) deckChoices.push(di);
    }
    if (!deckChoices.length) return null;

    let deckIndex;
    if (el.wheel.checked && deckChoices.length > 1) {
      deckIndex = deckChoices[Math.floor(Math.random() * deckChoices.length)];
    } else {
      deckIndex = deckChoices[0];
    }

    const idxs = filteredIndexByDeck[deckIndex];
    const cardIndex = idxs[Math.floor(Math.random() * idxs.length)];
    return { deckIndex, cardIndex };
  }

  function loadCurrent(ref) {
    showingBack = false;

    if (!ref) {
      current = null;
      el.cardText.textContent = "No cards match the current difficulty filter.";
      el.deckName.textContent = "‚Äî";
      el.faceLabel.textContent = "Idle";
      el.cardImg.style.display = "none";
      return;
    }

    const deck = decks[ref.deckIndex];
    const card = deck.cards[ref.cardIndex];
    current = { ...ref, card };

    setCardDisplay(card, deck.name, inBoss ? "Boss: Answer this" : "Quest: Answer this");
    setAnswerUI(card);
    setStatus();
  }

  // -----------------------------
  // Game loop
  // -----------------------------
  function startSprint(seconds) {
    if (!decks.length) {
      showModal("No deck loaded", "üìÑ", "Load a TSV/CSV deck first.");
      return;
    }

    rebuildFilters();

    running = true;
    inBoss = false;
    bossHP = 0;
    missQueue = [];

    remaining = seconds;

    correct = 0;
    missed = 0;
    streak = 0;
    power = 0;
    freezeUntil = 0;
    showingBack = false;

    setTimerDisplay(remaining);
    setStatus();

    loadCurrent(pickNextCardRef());

    if (tickHandle) clearInterval(tickHandle);
    tickHandle = setInterval(tick, 250);
  }

  function stopSprint() {
    running = false;
    inBoss = false;
    bossHP = 0;
    missQueue = [];
    freezeUntil = 0;

    if (tickHandle) clearInterval(tickHandle);
    tickHandle = null;

    setTimerDisplay(0);
    setStatus();

    const bestKey = bestKeyForSettings();
    const prevBest = safeInt(localStorage.getItem(bestKey) || "0", 0);
    const score = correct;

    if (score > prevBest) localStorage.setItem(bestKey, String(score));
    const bestNow = safeInt(localStorage.getItem(bestKey) || "0", 0);

    showModal(
      "Sprint complete",
      "üèÅ",
      `Score: <b>${score}</b> correct.<br/>Best for this setup: <b>${bestNow}</b>.<br/><br/><span class="tiny">Tip: 2-minute sprints beat 30-minute guilt spirals.</span>`
    );
  }

  function tick() {
    if (!running) return;

    const now = Date.now();

    // Freeze logic: timer does not decrease
    if (freezeUntil && now < freezeUntil) return;

    if (!tick._acc) tick._acc = 0;
    tick._acc += 0.25;

    if (tick._acc >= 1.0) {
      tick._acc = 0;
      remaining = Math.max(0, remaining - 1);
      setTimerDisplay(remaining);
      if (remaining <= 0) stopSprint();
    }
  }

  function bestKeyForSettings() {
    const d = el.diff.value;
    const w = el.wheel.checked ? "w1" : "w0";
    const m = el.mode.value;
    return `${LS_BEST}_${d}_${w}_${m}`;
  }

  // -----------------------------
  // Power-ups
  // -----------------------------
  function spendPower(cost) {
    if (power < cost) return false;
    power -= cost;
    setStatus();
    return true;
  }

  function useHint() {
    if (!current || !current.card) return;
    if (!spendPower(1)) {
      showModal("Not enough power", "‚ö°", "Earn power by getting answers correct.");
      return;
    }
    const h = current.card.hint || "No hint on this card. Add a hint column in the TSV/CSV for extra help.";
    el.hintBox.textContent = "Hint: " + h;
    el.hintBox.style.display = "block";
  }

  function useSkip() {
    if (!current || !current.card) return;
    if (!spendPower(1)) {
      showModal("Not enough power", "‚ö°", "Earn power by getting answers correct.");
      return;
    }
    streak = Math.max(0, streak - 1);
    maybeMovementPrompt();
    loadCurrent(pickNextCardRef());
  }

  function useFreeze() {
    if (!running) return;
    if (!spendPower(2)) {
      showModal("Not enough power", "‚ö°", "Freeze costs 2 power. Get more correct answers.");
      return;
    }
    freezeUntil = Date.now() + 10000;
    showModal("Timer frozen", "üßä", "You have 10 seconds where time does not move. Use it like a wizard.");
  }

  // -----------------------------
  // Reveal
  // -----------------------------
  function toggleReveal() {
    if (!current || !current.card) return;
    showingBack = !showingBack;

    const deck = decks[current.deckIndex];
    const label = showingBack ? "Answer revealed" : (inBoss ? "Boss: Answer this" : "Quest: Answer this");
    setCardDisplay(current.card, deck.name, label);
  }

  // -----------------------------
  // Answer grading
  // -----------------------------
  function normalizeAnswer(s) {
    return String(s || "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, " ");
  }

  function gradeAnswer(userAnswer) {
    if (!current || !current.card) return;

    const card = current.card;
    const expected = card.answer || card.back || "";
    const ok = normalizeAnswer(userAnswer) === normalizeAnswer(expected);

    if (ok) onCorrect();
    else onMissed();

    el.typedAnswer.value = "";
  }

  function onCorrect() {
    correct++;
    streak++;
    power = clamp(power + 1, 0, 5);

    if (correct > 0 && correct % 10 === 0) lootDrop();

    if (inBoss) {
      bossHP = Math.max(0, bossHP - 1);
      if (bossHP <= 0) {
        inBoss = false;
        showModal("Boss defeated", "üêâ", "Nice. The missed cards are not scary anymore.");
      }
    }

    setStatus();
    maybeMovementPrompt();
    loadCurrent(pickNextCardRef());
  }

  function onMissed() {
    missed++;
    streak = 0;

    missQueue.push({ deckIndex: current.deckIndex, cardIndex: current.cardIndex });

    if (!inBoss && missQueue.length >= 3) {
      inBoss = true;
      bossHP = Math.min(5, missQueue.length);
      showModal("Boss battle!", "üëπ", "Time to smack the missed cards. Each correct answer damages the boss.");
    }

    setStatus();
    maybeMovementPrompt();
    loadCurrent(pickNextCardRef());
  }

  function lootDrop() {
    const icon = LOOT[Math.floor(Math.random() * LOOT.length)];
    const loot = loadLoot();
    loot[icon] = (loot[icon] || 0) + 1;
    localStorage.setItem(LS_KEY, JSON.stringify(loot));
    showModal("Loot drop", icon, `You earned <b>${icon}</b>.<br/>Total: <b>${loot[icon]}</b>`);
  }

  function loadLoot() {
    try {
      return JSON.parse(localStorage.getItem(LS_KEY) || "{}") || {};
    } catch (e) {
      return {};
    }
  }

  function maybeMovementPrompt() {
    if (!el.movement.checked) return;
    const n = correct + missed;
    if (n > 0 && n % 7 === 0) {
      const msg = MOVES[Math.floor(Math.random() * MOVES.length)];
      showModal("Movement break", "üï∫", msg);
    }
  }

  // -----------------------------
  // TSV/CSV -> deck
  // -----------------------------
  function deckFromCSVText(csvText, name) {
    const delim = detectDelimiter(csvText);
    const rows = parseDelimited(csvText, delim);
    if (!rows.length) return null;

    const header = rows[0].map(normalizeHeader);
    const hasHeader = header.includes("front") && header.includes("back");

    let startRow = 0;
    let col = {
      front: 0,
      back: 1,
      answer: 2,
      choices: 3,
      hint: 4,
      tag: 5,
      difficulty: 6,
      front_image: 7,
      back_image: 8
    };

    if (hasHeader) {
      startRow = 1;
      col = {
        front: header.indexOf("front"),
        back: header.indexOf("back"),
        answer: header.indexOf("answer"),
        choices: header.indexOf("choices"),
        hint: header.indexOf("hint"),
        tag: header.indexOf("tag"),
        difficulty: header.indexOf("difficulty"),
        front_image: header.indexOf("front_image"),
        back_image: header.indexOf("back_image")
      };
    }

    const cards = [];

    for (let r = startRow; r < rows.length; r++) {
      const row = rows[r];

      const front = (row[col.front] ?? "").trim();
      const back = (row[col.back] ?? "").trim();
      const answer = col.answer >= 0 ? (row[col.answer] ?? "").trim() : "";
      const choicesRaw = col.choices >= 0 ? (row[col.choices] ?? "").trim() : "";
      const hint = col.hint >= 0 ? (row[col.hint] ?? "").trim() : "";
      const tag = col.tag >= 0 ? (row[col.tag] ?? "").trim() : "";
      const difficulty = col.difficulty >= 0 ? safeInt(row[col.difficulty], 0) : 0;
      const imgFront = col.front_image >= 0 ? (row[col.front_image] ?? "").trim() : "";
      const imgBack = col.back_image >= 0 ? (row[col.back_image] ?? "").trim() : "";

      if (!front && !back && !imgFront && !imgBack) continue;

      let choices = [];
      if (choicesRaw) choices = choicesRaw.split("|").map(s => s.trim()).filter(Boolean);

      const finalAnswer = answer || back;

      cards.push({
        front, back,
        answer: finalAnswer,
        choices,
        hint,
        tag,
        difficulty: difficulty || 0,
        imgFront,
        imgBack
      });
    }

    if (!cards.length) return null;
    return { name: name || "Deck", cards };
  }

  // -----------------------------
  // Events
  // -----------------------------
  el.closeModal.addEventListener("click", closeModal);
  el.modal.addEventListener("click", (e) => { if (e.target === el.modal) closeModal(); });

  el.file.addEventListener("change", async (e) => {
    const files = Array.from(e.target.files || []);
    if (!files.length) return;

    for (const f of files) {
      const text = await f.text();
      const deckName = f.name.replace(/\.(csv|tsv)$/i, "");
      const d = deckFromCSVText(text, deckName);
      if (d) decks.push(d);
    }

    rebuildFilters();
    setStatus();
    loadCurrent(pickNextCardRef());
  });

  el.loadPaste.addEventListener("click", () => {
    const t = el.csvPaste.value || "";
    const d = deckFromCSVText(t, "Pasted Deck");
    if (d) decks.push(d);

    rebuildFilters();
    setStatus();
    loadCurrent(pickNextCardRef());
  });

  el.clearAll.addEventListener("click", () => {
    decks = [];
    running = false;
    inBoss = false;
    missQueue = [];
    correct = 0;
    missed = 0;
    streak = 0;
    power = 0;
    freezeUntil = 0;
    showingBack = false;

    if (tickHandle) clearInterval(tickHandle);
    tickHandle = null;

    el.file.value = "";
    setTimerDisplay(0);
    setStatus();

    el.cardText.textContent = "Load a deck and start a sprint.";
    el.deckName.textContent = "‚Äî";
    el.faceLabel.textContent = "Ready";
    el.cardImg.style.display = "none";
    el.answerArea.style.display = "none";
    el.selfScoreRow.style.display = "flex";
  });

  el.loadSample.addEventListener("click", () => {
    const sample =
`front\tback\tanswer\tchoices\thint\ttag\tdifficulty\tfront_image\tback_image
What is 7x8?\t56\t56\t54|56|58|48\t7x4=28 then double\tmath\t2\t\t
Capitol of Washington?\tOlympia\tOlympia\tSeattle|Olympia|Tacoma|Spokane\tIt is not Seattle\tgeo\t1\t\t
Photosynthesis uses...\tSunlight to make food\tSunlight\tSunlight|Moonlight|Sound|Heat\tPlants are solar powered\tscience\t2\t\t
Spell: necessary\tnecessary\tnecessary\t\tDouble s\tspelling\t3\t\t
`;
    el.csvPaste.value = sample;
    const d = deckFromCSVText(sample, "Sample Deck");
    if (d) decks.push(d);

    rebuildFilters();
    setStatus();
    loadCurrent(pickNextCardRef());
  });

  // Settings change
  el.diff.addEventListener("change", () => { rebuildFilters(); loadCurrent(pickNextCardRef()); });
  el.wheel.addEventListener("change", () => { loadCurrent(pickNextCardRef()); });
  el.mode.addEventListener("change", () => { if (current && current.card) setAnswerUI(current.card); });

  // Start buttons
  document.querySelectorAll("[data-sprint]").forEach(btn => {
    btn.addEventListener("click", () => startSprint(safeInt(btn.getAttribute("data-sprint"), 120)));
  });
  el.stop.addEventListener("click", () => { if (running) stopSprint(); });

  // Reveal, self-score
  el.btnReveal.addEventListener("click", toggleReveal);
  el.gotIt.addEventListener("click", () => { if (running) onCorrect(); });
  el.missedIt.addEventListener("click", () => { if (running) onMissed(); });

  // Quiz submit
  function submitTyped() {
    if (!running) return;
    const v = el.typedAnswer.value || "";
    if (!v.trim()) {
      showModal("Type something", "üß†", "No pressure. Just take a swing.");
      return;
    }
    gradeAnswer(v);
  }
  el.submitAnswer.addEventListener("click", submitTyped);
  el.typedAnswer.addEventListener("keydown", (e) => {
    if (e.key === "Enter") submitTyped();
  });

  // Power-ups
  el.btnHint.addEventListener("click", useHint);
  el.btnSkip.addEventListener("click", useSkip);
  el.btnFreeze.addEventListener("click", useFreeze);

  // Keyboard shortcuts (avoid when typing)
  window.addEventListener("keydown", (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select") return;

    if (e.key.toLowerCase() === "h") { e.preventDefault(); useHint(); }
    if (e.key.toLowerCase() === "s") { e.preventDefault(); useSkip(); }
    if (e.key.toLowerCase() === "r") { e.preventDefault(); toggleReveal(); }
  });

  // Init
  setTimerDisplay(0);
  setStatus();
  updateCounter();
</script>
</body>
</html>
